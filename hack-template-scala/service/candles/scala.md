# Описание проекта

## Candles

Здесь лежит код, который вам предстоит модифицировать для решения задачи хакатона.

> В `build.sbt` можете добавить в этот проект любые нужные зависимости


## Задача

Реализовать pipeline для обработки свечей котировок криптовалют

`object Main` - входная точка приложения. Функция `def start` будет вызвана когда приложение запустится – 
ее вам и нужно модифицировать. Структура требует, чтобы вы вернули не код-результат исполнения, а 
инстанс класса `akka.actor.ActorRef`, через который в ваш стрим будут попадать
объекты класса `rht.common.domain.candles.Candle`


Вам нужно сделать akka streams Graph, который будет принимать `Candle`
и обрабатывать его, поддерживая как минимум:

- min/avg/max значения за все время работы приложения
- скользящее min/avg/max за 1, 5, 10 минут
- анализ срабатывания триггеров (про это ниже)

#### Триггеры

Клиент вашего сервиса хочет получать уведомления о событиях с котировками (например, "среднее за 10 минут достигло значения Х" или "текущее значение упало на N% от максимума за день").
Будем называть `триггером` – условие, при котором нужно создать событие, и действие, которое нужно выполнить. `Событием` будем называть информацию о пользователе, который зарегистрировал триггер, валюте, к которой привязан триггер, и контексте, по которому сработал триггер.

Таким образом, есть условие (триггер), действие и контекст для выполнения действия (событие).


> Например, пользователь зарегистрировал триггер с условием "падение цены биткоина на 10% от текущей" и действием "получить уведомление об этом в Telegram".
Тогда триггер имеет вид: `trigger = (id=trigger_1, figi=BTC, current_price=100, target_price=90, tg_notification)`. Событие, которое необходимо отправить при срабатывании триггера будет иметь вид:
`event = (user_1, BTC, price=90)`.
 

### Про объект Candle

`interval` – интервал свечи 

`figi` – единый глобальный идентификатор ценной бумаги (здесь эмулируется, но является уникальным для каждой криптовалюты). 
Список доступных идентификаторов можно посмотреть в объекте `rht.common.domain.candles.Figis` 

`details` – детали свечи

`details.low` – нижняя граница стоимости инструмента в этой свечи

`details.high` – верхняя граница стоимости инструмента в этой свечи

`details.open` – стоимость инструмента на момент открытия этой свечи

`details.close` – стоимость инструмента на момент закрытия этой свечи

`details.openTime` – время открытия этой свечи


## Запуск приложения

1. Приложение можно запустить с помощью sbt. Добавлен плагин `sbt-revolver`, поэтому можно запускать с помощью команд `<module-name>/reStart`, 
а останавливать с помощью `<module-name>/reStop`
2. Работа с Kafka (**Очень важно**)

    Каждая команда должна отредактировать файл `application.conf` и заменить значение `group.id` на следующее: `hackathon-<team-name>`, где team-name – название вашей команды. Если указать другое имя, у вас не будет прав на чтение стрима. 
    Если все команды сделают одинаковое значение, только одна команда будет получать данные из стрима


#### Объединение данных

Так как бэкенд для бота будет написан на Java, нужно решить, как организовать код. 
Это важно для передачи информации из стрима (реализуют ваши коллеги на scala) в бота.

Варианты:
1. Одно приложение (в одной программе запускается и стрим, и телеграм бот). 
Один будет процесс ОС, что означает, что данные будут находиться в общей памяти, а значит,
к ним легко получить доступ боту. Однако это же означает, что Java-разработчику придется
работать в этом sbt проекте, разбираться с его устройством, деталями работы и нужно будет следить за зависимостями 
в Java<->Scala коде

2. Разные приложения (разные процессы ОС). Это проще с точки зрения организации работы (каждый независимо делает свой модуль), но
требует дополнительной координации информации между процессами, так как общей памяти у них уже нет 


#### Рекомендации

- выбрать вариант 2, описанный выше (чтобы коллеге джависту было легче)
- использовать простое in-memory хранилище для обмена данными между приложениями (например, [redis](https://redis.io/), для которого есть куча библиотек на scala и java).
можно считать, что redis - `java ConcurrentHashMap`, в который есть доступ из любого процесса
- Telegram-боту делать polling данных из redis и отдавать заинтересованным пользователям

Если выберете вариант 1, можно делать то же самое с `ConcurrentHashMap`



## Заметки

#### ActorRef
Рекомендуется создать `Source` как `Source.actorRef` без backpressure, 
потому что это не будет поддерживаться источником сообщений. 
Можно установить размер буфера в 2000 сообщений – этого должно хватить для real-time обработки

Вы никак не ограничены в структуре графа, которым будет обрабатываться свеча

---

## Итого

 Ваш сервис должен уметь:
 1. обрабатывать стрим с котировками (методы анализа можете выбрать самостоятельно)
 2. регистрировать триггеры с webhook'ами в качестве действий. webhook – это механизм обратной связи при асинхронном взаимодействии систем. Вы можете реализовать это в виде хранения `(http method, url, payload)`, с которыми необходимо выполнить HTTP запрос. Сервис, обрабатывающий webhook, будут делать ваши коллеги из java команды
 3. отдавать метрики приложения через micrometer для prometheus. Конкретные метрики можете выбрать самостоятельно (например, число активных триггеров, число ошибок, курс конкретной криптовалюты)  
 
 